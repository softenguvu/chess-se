import { Board } from "./board.js";

// Function that handles adding event listeners to the chess board
function initBoardEvListener() {
    // First column. 'a' column
    const a1Board = document.getElementById("a1");
    a1Board.addEventListener("click", function(event) {
    });
>>>>>>> origin

    const a2Board = document.getElementById("a2");
    a2Board.addEventListener("click", function(event) {
    });

    const a3Board = document.getElementById("a3");
    a3Board.addEventListener("click", function(event) {
    });

    const a4Board = document.getElementById("a4");
    a4Board.addEventListener("click", function(event) {
    });

    const a5Board = document.getElementById("a5");
    a5Board.addEventListener("click", function(event) {
    });

    const a6Board = document.getElementById("a6");
    a6Board.addEventListener("click", function(event) {
    });

    const a7Board = document.getElementById("a7");
    a7Board.addEventListener("click", function(event) {
    });

    const a8Board = document.getElementById("a8");
    a8Board.addEventListener("click", function(event) {
    });

    // First column. 'b' column
    const b1Board = document.getElementById("b1");
    b1Board.addEventListener("click", function(event) {
    });

    const b2Board = document.getElementById("b2");
    b2Board.addEventListener("click", function(event) {
    });

    const b3Board = document.getElementById("b3");
    b3Board.addEventListener("click", function(event) {
    });

    const b4Board = document.getElementById("b4");
    b4Board.addEventListener("click", function(event) {
    });

    const b5Board = document.getElementById("b5");
    b5Board.addEventListener("click", function(event) {
    });

    const b6Board = document.getElementById("b6");
    b6Board.addEventListener("click", function(event) {
    });

    const b7Board = document.getElementById("b7");
    b7Board.addEventListener("click", function(event) {
    });

    const b8Board = document.getElementById("b8");
    b8Board.addEventListener("click", function(event) {
    });

    // First column. 'c' column
    const c1Board = document.getElementById("c1");
    c1Board.addEventListener("click", function(event) {
    });

    const c2Board = document.getElementById("c2");
    c2Board.addEventListener("click", function(event) {
    });

    const c3Board = document.getElementById("c3");
    c3Board.addEventListener("click", function(event) {
    });

    const c4Board = document.getElementById("c4");
    c4Board.addEventListener("click", function(event) {
    });

    const c5Board = document.getElementById("c5");
    c5Board.addEventListener("click", function(event) {
    });

    const c6Board = document.getElementById("c6");
    c6Board.addEventListener("click", function(event) {
    });

    const c7Board = document.getElementById("c7");
    c7Board.addEventListener("click", function(event) {
    });

    const c8Board = document.getElementById("c8");
    c8Board.addEventListener("click", function(event) {
    });

    // First column. 'd' column
    const d1Board = document.getElementById("d1");
    d1Board.addEventListener("click", function(event) {
    });

    const d2Board = document.getElementById("d2");
    d2Board.addEventListener("click", function(event) {
    });

    const d3Board = document.getElementById("d3");
    d3Board.addEventListener("click", function(event) {
    });

    const d4Board = document.getElementById("d4");
    d4Board.addEventListener("click", function(event) {
    });

    const d5Board = document.getElementById("d5");
    d5Board.addEventListener("click", function(event) {
    });

    const d6Board = document.getElementById("d6");
    d6Board.addEventListener("click", function(event) {
    });

    const d7Board = document.getElementById("d7");
    d7Board.addEventListener("click", function(event) {
    });

    const d8Board = document.getElementById("d8");
    d8Board.addEventListener("click", function(event) {
    });

    // First column. 'e' column
    const e1Board = document.getElementById("e1");
    e1Board.addEventListener("click", function(event) {
    });

    const e2Board = document.getElementById("e2");
    e2Board.addEventListener("click", function(event) {
    });

    const e3Board = document.getElementById("e3");
    e3Board.addEventListener("click", function(event) {
    });

    const e4Board = document.getElementById("e4");
    e4Board.addEventListener("click", function(event) {
    });

    const e5Board = document.getElementById("e5");
    e5Board.addEventListener("click", function(event) {
    });

    const e6Board = document.getElementById("e6");
    e6Board.addEventListener("click", function(event) {
    });

    const e7Board = document.getElementById("e7");
    e7Board.addEventListener("click", function(event) {
    });

    const e8Board = document.getElementById("e8");
    e8Board.addEventListener("click", function(event) {
    });

    // First column. 'f' column
    const f1Board = document.getElementById("f1");
    f1Board.addEventListener("click", function(event) {
    });

    const f2Board = document.getElementById("f2");
    f2Board.addEventListener("click", function(event) {
    });

    const f3Board = document.getElementById("f3");
    f3Board.addEventListener("click", function(event) {
    });

    const f4Board = document.getElementById("f4");
    f4Board.addEventListener("click", function(event) {
    });

    const f5Board = document.getElementById("f5");
    f5Board.addEventListener("click", function(event) {
    });

    const f6Board = document.getElementById("f6");
    f6Board.addEventListener("click", function(event) {
    });

    const f7Board = document.getElementById("f7");
    f7Board.addEventListener("click", function(event) {
    });

    const f8Board = document.getElementById("f8");
    f8Board.addEventListener("click", function(event) {
    });

    // First column. 'g' column
    const g1Board = document.getElementById("g1");
    g1Board.addEventListener("click", function(event) {
    });

    const g2Board = document.getElementById("g2");
    g2Board.addEventListener("click", function(event) {
    });

    const g3Board = document.getElementById("g3");
    g3Board.addEventListener("click", function(event) {
    });

    const g4Board = document.getElementById("g4");
    g4Board.addEventListener("click", function(event) {
    });

    const g5Board = document.getElementById("g5");
    g5Board.addEventListener("click", function(event) {
    });

    const g6Board = document.getElementById("g6");
    g6Board.addEventListener("click", function(event) {
    });

    const g7Board = document.getElementById("g7");
    g7Board.addEventListener("click", function(event) {
    });

    const g8Board = document.getElementById("g8");
    g8Board.addEventListener("click", function(event) {
    });

    // First column. 'h' column
    const h1Board = document.getElementById("h1");
    h1Board.addEventListener("click", function(event) {
    });

    const h2Board = document.getElementById("h2");
    h2Board.addEventListener("click", function(event) {
    });

    const h3Board = document.getElementById("h3");
    h3Board.addEventListener("click", function(event) {
    });

    const h4Board = document.getElementById("h4");
    h4Board.addEventListener("click", function(event) {
    });

    const h5Board = document.getElementById("h5");
    h5Board.addEventListener("click", function(event) {
    });

    const h6Board = document.getElementById("h6");
    h6Board.addEventListener("click", function(event) {
    });

    const h7Board = document.getElementById("h7");
    h7Board.addEventListener("click", function(event) {
    });

    const h8Board = document.getElementById("h8");
    h8Board.addEventListener("click", function(event) {
    });
}

initBoardEvListener();

// Add 'click' event-listener to the 'New Game' button.
const newGameButton = document.getElementById("new-game");
newGameButton.addEventListener("click", () => {
    board.reset();
    board.initBoard();
    board.renderPieces();
    playerOnePieces = [];
    playerTwoPieces = [];
    getPlayerPieces();
});

// Add 'click' event-listener to the 'Undo' button.
const undoButton = document.getElementById("undo-move");
undoButton.addEventListener("click", () =>
    console.log("Undo button: Click Event Triggered")
);

// This function get's run once, at the very beginning
function getPlayerPieces() {
    // Row zero and one go to player one
    for(let i = 0; i < board.board[0].length; ++i) {
        playerOnePieces.push(board.board[0][i]);
    }
    for(let i = 0; i < board.board[1].length; ++i) {
        playerOnePieces.push(board.board[1][i]);
    }

    // Row 6 and 7 go to player two
    for(let i = 0; i < board.board[6].length; ++i) {
        playerOnePieces.push(board.board[6][i]);
    }
    for(let i = 0; i < board.board[7].length; ++i) {
        playerOnePieces.push(board.board[7][i]);
    }
}

/**
 * This detects check at the beginning of someones turn
 * 
 */
function detectCheck(kingPiece, board) {
    /**
     * Define a function to check if pieces can attack each other
     */
    function harmsWay(underAttackPiece, possibleMoveSet) {
        let colPos = underAttackPiece.getColPos();
        let rowPos = underAttackPiece.getRowPos();

        for(let i = 0; i < possibleMoveSet.length; ++i) {
            if(possibleMoveSet[i][0] == rowPos && possibleMoveSet[i][1] == colPos) {
                return true;
            }
        }
        return false;
    }

    let defendingFriends = [];
    let attackingEnemies = [];

    let maxRows = board.length;
    let maxCols = board[0].length;
    let minRows, minCols = 0;

    /**
     * These are used to track the closest friendly piece and closest enemy pieces to see if king is actually under attack
     * and if a friendly piece moving would put the king in check.
     */
    let currClosestFriend = null;
    let currClosestEnemy = null;

    /**
     * Define a function that checks if the king is under attack, and resets the currClosest variables
     */
    function checkAndReset() {
        if (currClosestEnemy != null) {
            if (currClosestFriend == null) {
                attackingEnemies.push(currClosestEnemy);
            }
            else if (harmsWay(currClosestFriend, currClosestEnemy.possibleMoves(board))) {
                defendingFriends.push(currClosestFriend);
            }
        }
    
        currClosestFriend = null;
        currClosestEnemy = null;
    }

    /**
     * Get row increasing moves
     */
    for (let i = kingPiece.rowPos + 1; i < maxRows; i++) {
        if (board[i][kingPiece.colPos] !== undefined && board[i][kingPiece.colPos].getPlayerId() == kingPiece.playerId && currClosestFriend == null) {
            currClosestFriend = board[i][kingPiece.colPos];
        }
        if (board[i][kingPiece.colPos] !== undefined && board[i][kingPiece.colPos].getPlayerId() != kingPiece.playerId && currClosestEnemy == null) {
            currClosestEnemy = board[i][kingPiece.colPos];
        }
    }

    /**
     * Now check if the king is under attack and if there is a friendly piece in the way
     */
    checkAndReset();

    /**
     * Get row decreasing moves
     */
    for (let i = kingPiece.rowPos - 1; i >= minRows; i--) {
        if (board[i][kingPiece.colPos] !== undefined && board[i][kingPiece.colPos].getPlayerId() == kingPiece.playerId && currClosestFriend == null) {
            currClosestFriend = board[i][kingPiece.colPos];
        }
        if (board[i][kingPiece.colPos] !== undefined && board[i][kingPiece.colPos].getPlayerId() != kingPiece.playerId && currClosestEnemy == null) {
            currClosestEnemy = board[i][kingPiece.colPos];
        }
    }

     /**
     * Now check if the king is under attack and if there is a friendly piece in the way
     */
     checkAndReset();

    /**
     * Get col increasing moves
     */
    for (let i = kingPiece.colPos + 1; i < maxCols; i++) {
        if (board[kingPiece.rowPos][i] !== undefined && board[kingPiece.rowPos][i].getPlayerId() == kingPiece.playerId  && currClosestFriend == null) {
            currClosestFriend = board[kingPiece.rowPos][i];
        }
        if (board[kingPiece.rowPos][i] !== undefined && board[kingPiece.rowPos][i].getPlayerId() != kingPiece.playerId && currClosestEnemy == null) {
            currClosestEnemy = board[kingPiece.rowPos][i];
        }
    }

    /**
     * Now check if the king is under attack and if there is a friendly piece in the way
     */
    checkAndReset();

    /**
     * Get col decreasing moves
     */
    for (let i = kingPiece.colPos - 1; i >= minCols; i--) {
        if (board[kingPiece.rowPos][i] !== undefined && board[kingPiece.rowPos][i].getPlayerId() == kingPiece.playerId  && currClosestFriend == null) {
            currClosestFriend = board[kingPiece.rowPos][i];
        }
        if (board[kingPiece.rowPos][i] !== undefined && board[kingPiece.rowPos][i].getPlayerId() != kingPiece.playerId && currClosestEnemy == null) {
            currClosestEnemy = board[kingPiece.rowPos][i];
        }
    }

    /**
     * Now check if the king is under attack and if there is a friendly piece in the way
     */
    checkAndReset();

    /**
     * Get row and col increasing moves
     */
    for (let i = kingPiece.rowPos + 1, y = kingPiece.colPos + 1; i < maxRows && y < maxCols; i++, y++) {
        if (board[i][y] !== undefined && board[i][y].getPlayerId() == kingPiece.playerId && currClosestFriend == null) {
            currClosestFriend = board[i][y];
        }
        if (board[i][y] !== undefined && board[i][y].getPlayerId() != kingPiece.playerId && currClosestEnemy == null) {
            currClosestEnemy = board[i][y];
        }
    }
    
    /**
     * Now check if the king is under attack and if there is a friendly piece in the way
     */
    checkAndReset();

    /**
     * Get row and col decreasing moves
     */
    for (let i = kingPiece.rowPos - 1, y = kingPiece.colPos - 1; i >= minRows && y >= minCols; i--, y--) {
        if (board[i][y] !== undefined && board[i][y].getPlayerId() == kingPiece.playerId && currClosestFriend == null) {
            currClosestFriend = board[i][y];
        }
        if (board[i][y] !== undefined && board[i][y].getPlayerId() != kingPiece.playerId && currClosestEnemy == null) {
            currClosestEnemy = board[i][y];
        }
    }

    /**
     * Now check if the king is under attack and if there is a friendly piece in the way
     */
    checkAndReset();

    /**
     * Get row increasing and col decreasing moves
     */
    for (let i = kingPiece.rowPos + 1, y = kingPiece.colPos - 1; i < maxRows && y >= minCols; i++, y--) {
        if (board[i][y] !== undefined && board[i][y].getPlayerId() == kingPiece.playerId && currClosestFriend == null) {
            currClosestFriend = board[i][y];
        }
        if (board[i][y] !== undefined && board[i][y].getPlayerId() != kingPiece.playerId && currClosestEnemy == null) {
            currClosestEnemy = board[i][y];
        }
    }

    /**
     * Now check if the king is under attack and if there is a friendly piece in the way
     */
    checkAndReset();

    /**
     * Get row decreasing and col increasing moves
     */
    for (let i = kingPiece.rowPos - 1, y = kingPiece.colPos + 1; i >= minRows && y < maxCols; i--, y++) {
        if (board[i][y] !== undefined && board[i][y].getPlayerId() == kingPiece.playerId && currClosestFriend == null) {
            currClosestFriend = board[i][y];
        }
        if (board[i][y] !== undefined && board[i][y].getPlayerId() != kingPiece.playerId && currClosestEnemy == null) {
            currClosestEnemy = board[i][y];
        }
    }

    /**
     * Now check if the king is under attack and if there is a friendly piece in the way
     */
    checkAndReset();

    /**
     * Now check the spaces that only knights could attack from
     */
    const moveOffsets = [
        [-1, -2], [-2, -1], [-2, +1], [-1, +2],
        [+1, -2], [+2, -1], [+2, +1], [+1, +2]
    ];

    moveOffsets.forEach(([rowDiff, colDiff]) => {
        const row = kingPiece.rowPos + rowDiff;
        const col = kingPiece.colPos + colDiff;
        if ((0 <= row && row <= 7) && (0 <= col && col <= 7) && board[row][col] && board[row][col].getPlayerId() != kingPiece.playerId) {
            attackingEnemies.push(board[row][col]);
        }
    });

    return [attackingEnemies, defendingFriends];

}

/**
 * Detects checkmate using the previously defined check functions
 * 
 */
function detectCheckmate(kingPiece, board) {
    /**
     * See if the king has no possible moves
     */
    let possibleMoveSet = kingPiece.possibleMoves();
    let acceptableMoves = [];
    let attackingPieces = [];

    possibleMoveSet.forEach(([newRow, newCol]) => {
        const oldRow = kingPiece.getRowPos();
        const oldCol = kingPiece.getColPos();

        kingPiece.setRowPos(newRow);
        kingPiece.setColPos(newCol);

        res = detectCheck(kingPiece, board);

        if (res[0].length == 0) {
            acceptableMoves.push([newRow, newCol]);
            res[0].forEach((attackingPiece) => {
                attackingPieces.push(attackingPiece);
            });
        }

        kingPiece.setRowPos(oldRow);
        kingPiece.setColPos(oldCol);
    });

    if (acceptableMoves.length == 0) {
        console.log("King can't move out of his predicament");
    }

    /**
     * Now see if any of your pieces can block or take the attacking piece
     */
    if (attackingPieces.length == 1) {
        /**
         * Get the list of squares the piece attacks on
         */
        let attackVectors = [];
        attackingPieces.forEach((currPiece) => {
            let tempVectors = currPiece.possibleMoves();
            tempVectors.forEach((vectors) => {
                attackVectors.push(vectors);
            });
            attackVectors.push([currPiece.getRowPos(), currPiece.getColPos()]);
        });

        /**
         * Iterate through the list of friendly pieces seeing if any of their possible movesets include
         * the attacking piece, or can block it.
         */
        let powerPieces = [];
        if (kingPiece.playerId == 0) {
            // Use playerOnePieces
            playerOnePieces.forEach((piece) => {
                if (!piece.isTaken()) {
                    const pieceMoves = piece.possibleMoves();
                    for(i = 0; i < pieceMoves.length; ++i) {
                        for(j = 0; j < attackVectors.length; ++j) {
                            if(pieceMoves[i][0] == attackVectors[j][0] && pieceMoves[i][1] == attackVectors[j][1]) {
                                powerPieces.push(piece);
                            }
                        }
                    }
                }
            });
        }
        else {
            // Use playerTwoPieces
            playerTwoPieces.forEach((piece) => {
                if (!piece.isTaken()) {
                    const pieceMoves = piece.possibleMoves();
                    for(i = 0; i < pieceMoves.length; ++i) {
                        for(j = 0; j < attackVectors.length; ++j) {
                            if(pieceMoves[i][0] == attackVectors[j][0] && pieceMoves[i][1] == attackVectors[j][1]) {
                                powerPieces.push(piece);
                            }
                        }
                    }
                }
            });
        }
        return powerPieces;
    }
    else if (attackingPieces.length >= 2) {
        return true;
    }
    else {
        return false;
    }
}

let playerOnePieces = [];
let playerTwoPieces = [];
const board = new Board();
board.initBoard();
board.renderPieces();
getPlayerPieces();
